# rsa-pop-quiz
* **Points:** 200
* **Category:** Cryptography
* **Challenge Year:** 2019

## Description
> Class, take your seats! It's PRIME-time for a quiz... nc jupiter.challenges.picoctf.org 18821
>
> **HINT:** <a href="https://simple.wikipedia.org/wiki/RSA_algorithm">RSA info</a>

## Solution
I'm going to be honest and say that this one took a very long time. It's 2am now. It was a more reasonable hour when I started. Here's what I learned. 

1. Really big numbers... the numbers that we're dealing with in this challenge, behave in interesting ways. However, most languages have a syntax for dealing with them. Using that syntax (e.g. `pow()` and `\\` in python) will help eliminate suffering. 

2. I was tired of copy and pasting answers back into the test every time I got something wrong or accidently entered a bad input. I copied all of my answers into `answers.txt` and then ran 
`cat answers.txt | nc jupiter.challenges.picoctf.org 18821` which did all of the copy / pasting previously achieved answers for me. 

3. I learned **a lot** about how RSA works. Even potential ways to own it completely. There are two good youtube videos that you need to watch if you're like me and really want to understand WTF is happening instead of just blindly following a formula. 

nc jupiter.challenges.picoctf.org 18821

Public Key = (e, n)
Private Key = (d, n)

**To encrypt:**
ciphertext = plaintext^e(mod_n)

**To decrypt:**
plaintext = ciphertext^d(mod_n)

How does RSA Work? 

1. Pick two prime numbers. p and q. 
2. N is the product of p and q. 
3. The 'totient' of n is (p-1)(q-1)
4. e needs to be a value where 1 < e < totient(n), and should be coprime with n and totient(n)
5. d is a private key, and it can't be worked out easily without knowing the values of p and q. de(mod(totient(n))) = 1 



```
$ nc jupiter.challenges.picoctf.org 18821
Good morning class! It's me Ms. Adleman-Shamir-Rivest
Today we will be taking a pop quiz, so I hope you studied. Cramming just will not do!
You will need to tell me if each example is possible, given your extensive crypto knowledge.
Inputs and outputs are in decimal. No hex here!
#### NEW PROBLEM ####
q : 60413
p : 76753
##### PRODUCE THE FOLLOWING ####
n
IS THIS POSSIBLE and FEASIBLE? (Y/N):y
#### TIME TO SHOW ME WHAT YOU GOT! ###
n: 4636878989
Outstanding move!!!
```

n is just the product of q * p <br>
60413 * 76753 = **4636878989**

```
#### NEW PROBLEM ####
p : 54269
n : 5051846941
##### PRODUCE THE FOLLOWING ####
q
IS THIS POSSIBLE and FEASIBLE? (Y/N):y
#### TIME TO SHOW ME WHAT YOU GOT! ###
q: 93089
Outstanding move!!!
```

If n is the product of q and p, then it follows that q = n / p
5051846941 / 54269 = **93089**

```
#### NEW PROBLEM ####
e : 3
n : 12738162802910546503821920886905393316386362759567480839428456525224226445173031635306683726182522494910808518920409019414034814409330094245825749680913204566832337704700165993198897029795786969124232138869784626202501366135975223827287812326250577148625360887698930625504334325804587329905617936581116392784684334664204309771430814449606147221349888320403451637882447709796221706470239625292297988766493746209684880843111138170600039888112404411310974758532603998608057008811836384597579147244737606088756299939654265086899096359070667266167754944587948695842171915048619846282873769413489072243477764350071787327913
##### PRODUCE THE FOLLOWING ####
q
p
IS THIS POSSIBLE and FEASIBLE? (Y/N):n
Outstanding move!!!
```

It's not feasible, but it might be possible. <br>
Here's something worth checking out later. https://www.youtube.com/watch?v=-ShwJqAalOk <br>
For now, we press on with our test! 

```
#### NEW PROBLEM ####
q : 66347
p : 12611
##### PRODUCE THE FOLLOWING ####
totient(n)
IS THIS POSSIBLE and FEASIBLE? (Y/N):y
#### TIME TO SHOW ME WHAT YOU GOT! ###
totient(n): 836623060
Outstanding move!!!
```

We know totient(n) = (p-1)(q-1) <br>
So 66346 * 12610 = **836623060**


```
#### NEW PROBLEM ####
plaintext : 6357294171489311547190987615544575133581967886499484091352661406414044440475205342882841236357665973431462491355089413710392273380203038793241564304774271529108729717
e : 3
n : 29129463609326322559521123136222078780585451208149138547799121083622333250646678767769126248182207478527881025116332742616201890576280859777513414460842754045651093593251726785499360828237897586278068419875517543013545369871704159718105354690802726645710699029936754265654381929650494383622583174075805797766685192325859982797796060391271817578087472948205626257717479858369754502615173773514087437504532994142632207906501079835037052797306690891600559321673928943158514646572885986881016569647357891598545880304236145548059520898133142087545369179876065657214225826997676844000054327141666320553082128424707948750331
##### PRODUCE THE FOLLOWING ####
ciphertext
IS THIS POSSIBLE and FEASIBLE? (Y/N):y
#### TIME TO SHOW ME WHAT YOU GOT! ###
ciphertext: 256931246631782714357241556582441991993437399854161372646318659020994329843524306570818293602492485385337029697819837182169818816821461486018802894936801257629375428544752970630870631166355711254848465862207765051226282541748174535990314552471546936536330397892907207943448897073772015986097770443616540466471245438117157152783246654401668267323136450122287983612851171545784168132230208726238881861407976917850248110805724300421712827401063963117423718797887144760360749619552577176382615108244813
Outstanding move!!!
```

<a href="https://media.giphy.com/media/NsIwMll0rhfgpdQlzn/giphy.gif">This is where the fun begins.gif</a> <br>
We can solve this easily using the RSA encryption formula: <br>
`ciphertext = plaintext^e(mod n)` <br>
There's probably a sexier way to do this, but I just opened up python and assigned the variables for `plaintext`, `e`, and `n` and then just did like this: <br>
`>>> (plaintext ** 3) % n` 
Which returned the ciphertext value! 

```
#### NEW PROBLEM ####
ciphertext : 107524013451079348539944510756143604203925717262185033799328445011792760545528944993719783392542163428637172323512252624567111110666168664743115203791510985709942366609626436995887781674651272233566303814979677507101168587739375699009734588985482369702634499544891509228440194615376339573685285125730286623323
e : 3
n : 27566996291508213932419371385141522859343226560050921196294761870500846140132385080994630946107675330189606021165260590147068785820203600882092467797813519434652632126061353583124063944373336654246386074125394368479677295167494332556053947231141336142392086767742035970752738056297057898704112912616565299451359791548536846025854378347423520104947907334451056339439706623069503088916316369813499705073573777577169392401411708920615574908593784282546154486446779246790294398198854547069593987224578333683144886242572837465834139561122101527973799583927411936200068176539747586449939559180772690007261562703222558103359
##### PRODUCE THE FOLLOWING ####
plaintext
IS THIS POSSIBLE and FEASIBLE? (Y/N):n
Outstanding move!!!
```

`e` is the public key value that's used for encryption. We need `d` to decrypt the plaintext. We can't find `d` in this case because we don't know what the values for `p` and `q` are. But again, there are technically ways around this. If you can factor `n` into `p` and `q` easily, then this is feasible.  If n is a square number like `n = 49` then it's really easy. 


```
#### NEW PROBLEM ####
q : 92092076805892533739724722602668675840671093008520241548191914215399824020372076186460768206814914423802230398410980218741906960527104568970225804374404612617736579286959865287226538692911376507934256844456333236362669879347073756238894784951597211105734179388300051579994253565459304743059533646753003894559
p : 97846775312392801037224396977012615848433199640105786119757047098757998273009741128821931277074555731813289423891389911801250326299324018557072727051765547115514791337578758859803890173153277252326496062476389498019821358465433398338364421624871010292162533041884897182597065662521825095949253625730631876637
e : 65537
##### PRODUCE THE FOLLOWING ####
d
IS THIS POSSIBLE and FEASIBLE? (Y/N):y
#### TIME TO SHOW ME WHAT YOU GOT! ###
d: 1405046269503207469140791548403639533127416416214210694972085079171787580463776820425965898174272870486015739516125786182821637006600742140682552321645503743280670839819078749092730110549881891271317396450158021688253989767145578723458252769465545504142139663476747479225923933192421405464414574786272963741656223941750084051228611576708609346787101088759062724389874160693008783334605903142528824559223515203978707969795087506678894006628296743079886244349469131831225757926844843554897638786146036869572653204735650843186722732736888918789379054050122205253165705085538743651258400390580971043144644984654914856729
Outstanding move!!!
```

Now that we have `p` and `q` we can find `d` easily. <br>
First we need to calculate `phi` or 'totient(n)' like we did above. After assigning the values of `p` and `q` we can do like this: 
`phi = (p - 1) * (q - 1)` and now we have a `phi` value that we can work with. <br>
We still need to find `d` where `(d * e) % phi = 1`<br>
This can be expressed as: <br>
`d = (e ** -1) % phi`
Python 3.8 has a native module 'pow' that we can use to find the modular multiplicative inverse here. `pow()` takes three arguments: a number, the power you're raising it to, and a mod value. So with `pow()`, we can get `d` by doing like this: <br>
`d = pow(e, -1, phi)`

```
#### NEW PROBLEM ####
p : 153143042272527868798412612417204434156935146874282990942386694020462861918068684561281763577034706600608387699148071015194725533394126069826857182428660427818277378724977554365910231524827258160904493774748749088477328204812171935987088715261127321911849092207070653272176072509933245978935455542420691737433
ciphertext : 13433290949680532374013867441263154634705815037382789341947905025573905974395028146503162155477260989520870175638250366834087929309236841056522311567941474209163559687755762232926539910909326834168973560610986090744435081572047926364479629414399701920441091626046861493465214197526650146669009590360242375313096062285541413327190041808752295242278877995930751460977420696964385608409717277431821765402461515639686537904799084682553530460611519251872463837425068958992042166507373556839377045616866221238932332390930404993242351071392965945718308504231468783743378794612151028803489143522912976113314577732444166162766
e : 65537
n : 23952937352643527451379227516428377705004894508566304313177880191662177061878993798938496818120987817049538365206671401938265663712351239785237507341311858383628932183083145614696585411921662992078376103990806989257289472590902167457302888198293135333083734504191910953238278860923153746261500759411620299864395158783509535039259714359526738924736952759753503357614939203434092075676169179112452620687731670534906069845965633455748606649062394293289967059348143206600765820021392608270528856238306849191113241355842396325210132358046616312901337987464473799040762271876389031455051640937681745409057246190498795697239
##### PRODUCE THE FOLLOWING ####
plaintext
IS THIS POSSIBLE and FEASIBLE? (Y/N):#### TIME TO SHOW ME WHAT YOU GOT! ###
plaintext: Outstanding move!!!


If you convert the last plaintext to a hex number, then ascii, you'll find what you need! ;)
```

We can use the decryption formula to solve: `plaintext = ciphertext ** d % n`, but we need to find the value of `d` first, which requires the value of `phi`, which requires knowing `q`. 

q _should_ be equal to n / p but it's not! 

```
>>> 5 == (5 / 4) * 4
True
>>> n == (n / p) * p
False

```

What the actual F***? Am I mathematically cursed? My reasoning is sound, but I think something weird is happening when I'm dividing these very large numbers. 

```
>>> n == (n // p) * p
True
>>> q = (n // p)
>>> n == (p * q)
True
```

I needed to use the floor division operator `//` here. This is because python `/` division automatically products a float number. This is fine That was quite a detour, but we finally have a value for `q`! Let's assign `phi` and `d` to varibles now because why not?<br>

```
>>> phi = (p - 1) * (q - 1)
>>> d = pow(e, -1, phi)
```

If you try to do something like `plaintext = ciphertext ** d % n` in python you're going to have a bad time. Trust me. I tried this. It ran and ran and ran and never completed. These are really astromonically huge numbers so we need to use `pow()`just like we did to calcuate `d`. `plaintext = pow(ciphertext, d, n)`<br>
<br>

The final part of the challenge asks us to convert the plaintext number value into hexidecimal and then ascii. The final python script looks like this. 



```python 3
# variables from challege

p = 153143042272527868798412612417204434156935146874282990942386694020462861918068684561281763577034706600608387699148071015194725533394126069826857182428660427818277378724977554365910231524827258160904493774748749088477328204812171935987088715261127321911849092207070653272176072509933245978935455542420691737433

ciphertext = 13433290949680532374013867441263154634705815037382789341947905025573905974395028146503162155477260989520870175638250366834087929309236841056522311567941474209163559687755762232926539910909326834168973560610986090744435081572047926364479629414399701920441091626046861493465214197526650146669009590360242375313096062285541413327190041808752295242278877995930751460977420696964385608409717277431821765402461515639686537904799084682553530460611519251872463837425068958992042166507373556839377045616866221238932332390930404993242351071392965945718308504231468783743378794612151028803489143522912976113314577732444166162766

e = 65537

n = 23952937352643527451379227516428377705004894508566304313177880191662177061878993798938496818120987817049538365206671401938265663712351239785237507341311858383628932183083145614696585411921662992078376103990806989257289472590902167457302888198293135333083734504191910953238278860923153746261500759411620299864395158783509535039259714359526738924736952759753503357614939203434092075676169179112452620687731670534906069845965633455748606649062394293289967059348143206600765820021392608270528856238306849191113241355842396325210132358046616312901337987464473799040762271876389031455051640937681745409057246190498795697239

# calcuated variables

q = n // p 

phi = (p - 1) * (q - 1)

d = pow(e, -1, phi)

plaintext = pow(ciphertext, d, n)
print(plaintext)

# convert to hex, then convert to string
hexstring = hex(plaintext)
hexstring = hexstring[2:]
bytes_object = bytes.fromhex(hexstring)
ascii_string = bytes_object.decode("ASCII")
print(f"FLAG:{ascii_string}")
```

:black_flag: **flag:**`picoCTF{wA8_th4t$_ill3aGal..oa2d2239b}`
